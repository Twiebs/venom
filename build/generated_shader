#version 430 core
#extension GL_ARB_explicit_uniform_location : require
#extension GL_ARB_shading_language_420pack : require

#define SHADOW_MAP_RESOLUTION 4096
#define SHADOW_MAP_CASCADE_COUNT 8
#define SHADOW_MAP_CASCADE_WEIGHT 0.75
#define SHADOW_MAP_CASCADE_TOLERANCE 1.005f
#define TERRAIN_MATERIAL_COUNT 2
#define TERRAIN_HEIGHT_SCALAR 32.0f
#define DIRECTIONAL_LIGHTS_MAX 1
#define SHADOW_CASTING_POINT_LIGHT_MAX 8
#define POINT_LIGHTS_MAX 16
#define DIRECTIONAL_LIGHT_UNIFORM_LOCATION 8
#define SSAO_SAMPLE_COUNT 64
#define SSAO_NOISE_SIZE 4

#define POINT_LIGHT_UNIFORM_LOCATION 10
#define SHADOW_CASTING_POINT_LIGHT_UNIFORM_LOCATION 58

layout (location = 2) uniform vec3 uLightPosition;

in VSOut {
  vec3 rayDirection;
  vec3 scatteringColor;
} fsIn;

out vec4 outColor;

const float MIE_SCATTERING_CONSTANT = -0.75f;
const float MIE_SCATTERING_CONSTANT_SQUARED = MIE_SCATTERING_CONSTANT * MIE_SCATTERING_CONSTANT;

void main(){
  //outColor = vec4(1.0);

  float fCos = dot(uLightPosition, fsIn.rayDirection) / length(fsIn.rayDirection);
  float fMiePhase = 1.5 * ((1.0 - MIE_SCATTERING_CONSTANT_SQUARED) / (2.0 + MIE_SCATTERING_CONSTANT_SQUARED)) * 
    (1.0 + fCos*fCos) / pow(1.0 + MIE_SCATTERING_CONSTANT_SQUARED - 2.0*MIE_SCATTERING_CONSTANT*fCos, 1.5);

  outColor = vec4(fsIn.scatteringColor + fMiePhase, 1.0);
  outColor.a = outColor.b;
}
