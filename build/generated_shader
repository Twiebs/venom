#version 430 core
#extension GL_ARB_explicit_uniform_location : require
#extension GL_ARB_shading_language_420pack : require

#define SHADOW_MAP_RESOLUTION 4096
#define SHADOW_MAP_CASCADE_COUNT 8
#define SHADOW_MAP_CASCADE_WEIGHT 0.75
#define SHADOW_MAP_CASCADE_TOLERANCE 1.005f
#define TERRAIN_MATERIAL_COUNT 2
#define TERRAIN_HEIGHT_SCALAR 32.0f
#define DIRECTIONAL_LIGHTS_MAX 1
#define SHADOW_CASTING_POINT_LIGHT_MAX 8
#define POINT_LIGHTS_MAX 16
#define DIRECTIONAL_LIGHT_UNIFORM_LOCATION 8
#define SSAO_SAMPLE_COUNT 64
#define SSAO_NOISE_SIZE 4

#define POINT_LIGHT_UNIFORM_LOCATION 10
#define SHADOW_CASTING_POINT_LIGHT_UNIFORM_LOCATION 58
const float FOG_DENSITY = 0.005f;
const float FOG_GRADIENT = 2.0f;

#define TERRAIN_CHUNK_PER_EDGE 31
#define TERRAIN_CHUNK_SIZE 31

#define UniformLocation_ModelMatrix 0
#define UniformLocation_ViewMatrix  1
#define UniformLocation_ProjectionMatrix 2
#define UniformLocation_LightSpaceMatrices 3
#define UniformLocation_CameraViewPosition 4

layout (location = UniformLocation_ModelMatrix) uniform mat4 u_model_matrix;
layout (location = UniformLocation_ViewMatrix) uniform mat4 u_view_matrix;
layout (location = UniformLocation_ProjectionMatrix) uniform mat4 u_projection_matrix;
layout (location = UniformLocation_CameraViewPosition) uniform vec3 u_camera_view_position;

uniform mat4 u_light_space_matrix[4];

mat3 CalculateTBNMatrix (vec3 normal, vec3 tangent, mat4 modelMatrix) {
  vec3 bitangent = cross(normalize(tangent), normalize(normal));
  vec3 t = normalize(vec3(modelMatrix * vec4(normalize(tangent),   0.0)));
  vec3 b = normalize(vec3(modelMatrix * vec4(normalize(bitangent), 0.0)));
  vec3 n = normalize(vec3(modelMatrix * vec4(normalize(normal),    0.0)));
  mat3 result = mat3(t, b, n);
  return result;
}

float apply_atmospheric_fog(vec3 position) {
  float fog_end = (TERRAIN_CHUNK_SIZE * 
    float(TERRAIN_CHUNK_PER_EDGE*0.5)) - (TERRAIN_CHUNK_SIZE * 1.25);
	float fog_start = (TERRAIN_CHUNK_SIZE * 
    float(TERRAIN_CHUNK_PER_EDGE*0.5)) - (TERRAIN_CHUNK_SIZE * 5);
	float distance_to_vertex = length(u_camera_view_position - position);

	float fog_factor = clamp((fog_end - distance_to_vertex) / 
    (fog_end - fog_start), 0.0, 1.0);
	return fog_factor;
}


layout (location = 0) in vec2 in_position;
layout (location = 1) in mat4 in_model_matrix;

layout (binding = 5) uniform sampler2DArray height_sampler;
layout (binding = 6) uniform sampler2DArray normal_sampler;
layout (binding = 7) uniform sampler2DArray u_detail_sampler;

out VS_OUT
{
	vec3 position;
	vec3 normal;
	vec2 texcoord;
	float visibility;
	vec4 light_space_position;
	flat int instance_id;
	float terrain_detail;
} vs_out;

void main() {
	vec2 material_texcoord = in_position * (1.0 / 8.0);

	int ix = int(in_position.x);
	int iy = int(in_position.y);

	float terrain_height = texelFetch(height_sampler, ivec3(ix, iy, gl_InstanceID), 0).r;
	float terrain_detail = texelFetch(u_detail_sampler, ivec3(ix, iy, gl_InstanceID), 0).r;
	vec3  terrain_normal = texelFetch(normal_sampler, ivec3(ix, iy, gl_InstanceID), 0).xyz;

	terrain_height *= 0.0f;


	vec4 world_position = in_model_matrix * vec4(in_position.x, terrain_height, in_position.y, 1.0);

	vs_out.position = world_position.xyz;
	vs_out.texcoord = material_texcoord;
	vs_out.normal   = terrain_normal;
	vs_out.visibility = apply_atmospheric_fog(world_position.xyz);
	vs_out.terrain_detail = terrain_detail;
	gl_Position = u_projection_matrix * u_view_matrix * world_position;
}
